"use client";

import type React from "react";

import { useState, useMemo } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Plus, AlertCircle, CalendarRange, Sparkles } from "lucide-react";
import { toast } from "@/lib/toast";
import {
  addEventDay,
  bulkAddEventDays,
  deleteEventDay,
  updateEventDay,
  updateEventDaysOrder,
  type EventDayOutput,
} from "@/actions/event-days";
import { DayCard } from "@/components/event-days/day-card";
import { DayDetailSheet } from "@/components/event-days/day-detail-sheet";
import { DayTimelineHeader } from "@/components/event-days/day-timeline-header";
import { AutoGenerateDialog } from "@/components/event-days/auto-generate-dialog";

type EventDay = EventDayOutput;

interface EventDaysContentProps {
  eventId: string;
  initialDays: EventDay[];
}

export function EventDaysContent({
  eventId,
  initialDays,
}: EventDaysContentProps) {
  const [days, setDays] = useState<EventDay[]>(initialDays);
  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);
  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null);

  // New state for detail sheet and auto-generate
  const [selectedDayId, setSelectedDayId] = useState<string | null>(null);
  const [isDetailSheetOpen, setIsDetailSheetOpen] = useState(false);
  const [isAutoGenerateOpen, setIsAutoGenerateOpen] = useState(false);
  const [isAddingDay, setIsAddingDay] = useState(false);
  const [newDayName, setNewDayName] = useState("");

  // Calculate event duration summary
  const durationSummary = useMemo(() => {
    if (days.length === 0) return null;

    const validDates = days
      .filter((d) => d.date)
      .map((d) => new Date(d.date))
      .sort((a, b) => a.getTime() - b.getTime());

    if (validDates.length === 0) return null;

    const firstDate = validDates[0];
    const lastDate = validDates[validDates.length - 1];

    const formatDate = (date: Date) => {
      return date.toLocaleDateString("es-ES", {
        weekday: "short",
        day: "numeric",
        month: "short",
      });
    };

    const daysDiff =
      Math.ceil(
        (lastDate.getTime() - firstDate.getTime()) / (1000 * 60 * 60 * 24)
      ) + 1;

    return {
      start: formatDate(firstDate),
      end: formatDate(lastDate),
      totalDays: daysDiff,
      configuredDays: days.length,
    };
  }, [days]);

  // Validation warnings
  const warnings = useMemo(() => {
    const issues: string[] = [];

    // Check for days without dates
    const daysWithoutDates = days.filter((d) => !d.date);
    if (daysWithoutDates.length > 0) {
      issues.push(`${daysWithoutDates.length} día(s) sin fecha configurada`);
    }

    // Check for out of order dates
    const sortedByDate = [...days]
      .filter((d) => d.date)
      .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

    const isOutOfOrder = days.some((day, index) => {
      if (!day.date) return false;
      const sortedIndex = sortedByDate.findIndex((d) => d.id === day.id);
      return sortedIndex !== -1 && sortedIndex !== index;
    });

    if (isOutOfOrder) {
      issues.push("Las fechas no están en orden cronológico");
    }

    return issues;
  }, [days]);

  const selectedDay = useMemo(
    () => days.find((d) => d.id === selectedDayId) || null,
    [days, selectedDayId]
  );

  const selectedDayNumber = useMemo(() => {
    const index = days.findIndex((d) => d.id === selectedDayId);
    return index >= 0 ? index + 1 : 0;
  }, [days, selectedDayId]);

  const addDay = async () => {
    if (!newDayName.trim()) {
      toast.error({ title: "Por favor ingresa un nombre para el día" });
      return;
    }

    // Auto-suggest next day's date based on last day
    let suggestedDate = "";
    if (days.length > 0) {
      const lastDay = days[days.length - 1];
      if (lastDay.date) {
        const lastDate = new Date(lastDay.date);
        lastDate.setDate(lastDate.getDate() + 1);
        suggestedDate = lastDate.toISOString();
      }
    }

    const newDayData = {
      name: newDayName.trim(),
      date: suggestedDate,
      endDate: "",
      sortOrder: days.length,
      description: "",
      flyer: "",
      doorsOpen: "",
      showStart: "",
    };

    // Call server action to insert into database
    const result = await addEventDay(eventId, newDayData);

    if (result.success && result.day) {
      setDays([...days, result.day]);
      setNewDayName("");
      setIsAddingDay(false);
      toast.success({ title: "Día agregado. Haz clic para configurarlo." });
    } else {
      toast.error({ title: result.message || "Error al agregar el día" });
    }
  };

  const handleAutoGenerate = async (newDays: Partial<EventDay>[]) => {
    const daysData = newDays.map((d, index) => ({
      name: d.name || "",
      date: d.date || "",
      endDate: d.endDate || "",
      sortOrder: d.sortOrder || days.length + index,
      description: "",
      flyer: "",
      doorsOpen: "",
      showStart: "",
    }));

    // Call server action to bulk insert into database
    const result = await bulkAddEventDays(eventId, daysData);

    if (result.success && result.days) {
      setDays([...days, ...result.days]);
      toast.success({
        title: `${result.days.length} días generados exitosamente`,
      });
    } else {
      toast.error({ title: result.message || "Error al generar los días" });
    }
  };

  const updateDay = async (dayId: string, updates: EventDay) => {
    // Call server action to update in database
    const result = await updateEventDay(dayId, updates);

    if (result.success) {
      const newDays = days.map((day) =>
        day.id === dayId ? { ...updates } : day
      );
      setDays(newDays);
      toast.success({ title: "Día actualizado exitosamente" });
    } else {
      toast.error({ title: result.message || "Error al actualizar el día" });
    }
  };

  const duplicateDay = async (index: number) => {
    const dayToDuplicate = days[index];

    // Calculate next day's date
    let nextDate = "";
    let nextEndDate = "";
    if (dayToDuplicate.date) {
      const originalDate = new Date(dayToDuplicate.date);
      originalDate.setDate(originalDate.getDate() + 1);
      nextDate = originalDate.toISOString();

      if (dayToDuplicate.endDate) {
        const originalEndDate = new Date(dayToDuplicate.endDate);
        originalEndDate.setDate(originalEndDate.getDate() + 1);
        nextEndDate = originalEndDate.toISOString();
      }
    }

    const newDayData = {
      name: `${dayToDuplicate.name} (copia)`,
      date: nextDate,
      endDate: nextEndDate,
      sortOrder: index + 1,
      description: dayToDuplicate.description || "",
      flyer: dayToDuplicate.flyer || "",
      doorsOpen: dayToDuplicate.doorsOpen || "",
      showStart: dayToDuplicate.showStart || "",
    };

    // Call server action to insert the duplicated day
    const result = await addEventDay(eventId, newDayData);

    if (result.success && result.day) {
      // Insert after the duplicated day
      const newDays = [...days];
      newDays.splice(index + 1, 0, result.day);

      // Update sort orders
      const updates = newDays.map((day, i) => ({
        id: day.id,
        sortOrder: i,
      }));

      // Update sort orders in database
      await updateEventDaysOrder(updates);

      // Update local state with new sort orders
      newDays.forEach((day, i) => {
        day.sortOrder = i;
      });

      setDays(newDays);
      toast.success({ title: "Día duplicado exitosamente" });
    } else {
      toast.error({ title: result.message || "Error al duplicar el día" });
    }
  };

  const removeDay = async (index: number) => {
    const dayToRemove = days[index];

    // Call server action to delete from database
    const result = await deleteEventDay(dayToRemove.id);

    if (result.success) {
      const newDays = days.filter((_, i) => i !== index);

      // Update sort orders
      const updates = newDays.map((day, i) => ({
        id: day.id,
        sortOrder: i,
      }));

      // Update sort orders in database if there are remaining days
      if (updates.length > 0) {
        await updateEventDaysOrder(updates);
      }

      // Update local state with new sort orders
      newDays.forEach((day, i) => {
        day.sortOrder = i;
      });

      setDays(newDays);
      toast.success({ title: "Día eliminado" });
    } else {
      toast.error({ title: result.message || "Error al eliminar el día" });
    }
  };

  const handleDragStart = (index: number) => {
    setDraggedIndex(index);
  };

  const handleDragOver = (e: React.DragEvent, index: number) => {
    e.preventDefault();
    if (draggedIndex !== null && draggedIndex !== index) {
      setDragOverIndex(index);
    }
  };

  const handleDrop = async (dropIndex: number) => {
    if (draggedIndex === null || draggedIndex === dropIndex) {
      setDraggedIndex(null);
      setDragOverIndex(null);
      return;
    }

    const newDays = [...days];
    const draggedItem = newDays[draggedIndex];
    newDays.splice(draggedIndex, 1);
    newDays.splice(dropIndex, 0, draggedItem);

    // Update sort orders
    const updates = newDays.map((day, i) => ({
      id: day.id,
      sortOrder: i,
    }));

    // Call server action to update sort orders in database
    const result = await updateEventDaysOrder(updates);

    if (result.success) {
      // Update local state with new sort orders
      newDays.forEach((day, i) => {
        day.sortOrder = i;
      });

      setDays(newDays);
    } else {
      toast.error({ title: result.message || "Error al reordenar los días" });
    }

    setDraggedIndex(null);
    setDragOverIndex(null);
  };

  const handleDragEnd = () => {
    setDraggedIndex(null);
    setDragOverIndex(null);
  };

  const handleDayClick = (dayId: string) => {
    setSelectedDayId(dayId);
    setIsDetailSheetOpen(true);
  };

  return (
    <div className="space-y-6 max-w-6xl">
      {/* Duration Summary Card */}
      {durationSummary && (
        <Card className="bg-gradient-to-r from-zinc-900 to-zinc-800 border-zinc-700">
          <CardContent className="py-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-white/10 rounded-lg">
                  <CalendarRange className="w-5 h-5 text-white" />
                </div>
                <div>
                  <p className="text-sm text-zinc-400">Duración del evento</p>
                  <p className="text-lg font-semibold text-white">
                    {durationSummary.start} → {durationSummary.end}
                  </p>
                </div>
              </div>
              <div className="text-right">
                <p className="text-2xl font-bold text-white">
                  {durationSummary.configuredDays}
                </p>
                <p className="text-sm text-zinc-400">días configurados</p>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Warnings */}
      {warnings.length > 0 && (
        <Card className="border-yellow-500/50 bg-yellow-500/10">
          <CardContent className="py-3">
            <div className="flex items-start gap-3">
              <AlertCircle className="w-5 h-5 text-yellow-500 flex-shrink-0 mt-0.5" />
              <div className="space-y-1">
                {warnings.map((warning, i) => (
                  <p key={i} className="text-sm text-yellow-200">
                    {warning}
                  </p>
                ))}
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Timeline Header */}
      {days.length > 0 && (
        <DayTimelineHeader
          days={days}
          selectedDayId={selectedDayId}
          onDayClick={handleDayClick}
        />
      )}

      {/* Action Bar */}
      <div className="flex gap-3">
        {!isAddingDay ? (
          <>
            <Button
              type="button"
              onClick={() => setIsAddingDay(true)}
              variant="outline"
              className="gap-2"
            >
              <Plus className="w-4 h-4" />
              Agregar Día
            </Button>
            <Button
              type="button"
              onClick={() => setIsAutoGenerateOpen(true)}
              variant="outline"
              className="gap-2"
            >
              <Sparkles className="w-4 h-4" />
              Auto-Generar Días
            </Button>
          </>
        ) : (
          <div className="flex gap-2 items-center flex-1 max-w-md">
            <Input
              autoFocus
              value={newDayName}
              onChange={(e) => setNewDayName(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === "Enter") {
                  addDay();
                } else if (e.key === "Escape") {
                  setIsAddingDay(false);
                  setNewDayName("");
                }
              }}
              placeholder="Nombre del día (ej: Viernes, Día 1...)"
              className="flex-1"
            />
            <Button onClick={addDay} size="sm">
              Agregar
            </Button>
            <Button
              onClick={() => {
                setIsAddingDay(false);
                setNewDayName("");
              }}
              variant="ghost"
              size="sm"
            >
              Cancelar
            </Button>
          </div>
        )}
      </div>

      {/* Days List */}
      <Card>
        <CardHeader>
          <CardTitle>Días del Evento</CardTitle>
          <CardDescription>
            Haz clic en un día para configurarlo. Arrastra para reordenar.
          </CardDescription>
        </CardHeader>
        <CardContent>
          {days.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-12 px-4 border-2 border-dashed border-zinc-200 dark:border-zinc-800 rounded-xl">
              <p className="text-zinc-500 dark:text-zinc-400 text-center mb-4">
                No hay días configurados. Agrega el primer día para comenzar.
              </p>
            </div>
          ) : (
            <div className="space-y-3">
              {days.map((day, index) => (
                <DayCard
                  key={day.id}
                  day={day}
                  index={index}
                  isSelected={day.id === selectedDayId}
                  isDragging={draggedIndex === index}
                  isDragOver={dragOverIndex === index}
                  onSelect={() => handleDayClick(day.id)}
                  onDragStart={() => handleDragStart(index)}
                  onDragOver={(e) => handleDragOver(e, index)}
                  onDragLeave={() => setDragOverIndex(null)}
                  onDrop={() => handleDrop(index)}
                  onDragEnd={handleDragEnd}
                  onRemove={() => removeDay(index)}
                  onDuplicate={() => duplicateDay(index)}
                />
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Detail Sheet */}
      <DayDetailSheet
        day={selectedDay}
        dayNumber={selectedDayNumber}
        open={isDetailSheetOpen}
        onOpenChange={setIsDetailSheetOpen}
        onSave={(updatedDay) => updateDay(selectedDayId!, updatedDay)}
      />

      {/* Auto Generate Dialog */}
      <AutoGenerateDialog
        open={isAutoGenerateOpen}
        onOpenChange={setIsAutoGenerateOpen}
        onGenerate={handleAutoGenerate}
        existingDays={days}
      />
    </div>
  );
}
